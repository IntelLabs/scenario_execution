import osc.robotics

enum comparison_operator: [
    lt,
    le,
    eq,
    ne,
    ge,
    gt
]

enum qos_preset_profiles: [
    parameters,
    parameter_events,
    sensor_data,
    services_default,
    system_default
]

enum lifecycle_state: [
  unconfigured,
  inactive,
  active,
  finalized
]

actor differential_drive_robot inherits robot:
    namespace: string = ''

struct msg_conversion:
    def to_dict(in_value: string, member_name: string = "") -> pose_3d is external scenario_execution_ros.external_methods.msg_conversion.to_dict()
    def to_pose3d(in_value: string) -> pose_3d is external scenario_execution_ros.external_methods.msg_conversion.to_pose3d()

action action_call:
    # Call a ros action and wait for the result
    action_name: string                  # name of the action to connect to
    action_type: string                  # class of the message type
    data: string                         # call content
    transient_local: bool = false

action assert_lifecycle_state:
    # Checks for the state of a lifecycle-managed node.
    node_name: string                    # Name of lifecycle-managed node
    state_sequence: list of lifecycle_state # list of allowed lifecycle states to follow
    allow_initial_skip: bool = false     # if true, allows skipping of states within the state_sequence without reporting failure
    fail_on_unexpected: bool = true      # if true and an unexpected transition or final state occurs, the action fails. Otherwise it succeed.
    keep_running: bool = true            # if true, the action keeps running while the last state in the state_sequence remains

action assert_tf_moving:
    # Checks that a tf frame_id keeps moving in respect to a parent_frame_id. If there is no movement within timeout the action ends with failure.
    # Speeds below threshold_translation and threshold_rotation are discarded. By default the action waits for the first transform to get available
    # before starting the timeout timer. This can be changed by setting wait_for_first_transform to false. If the tf topics are not available 
    # on /tf and /tf_static you can specify a namespace by setting tf_topic_namespace.
    frame_id: string                     # frame_id to check for movement
    parent_frame_id: string = "map"      # parent frame_id against which the movement is checked
    timeout: time                        # timeout without movement
    threshold_translation: speed = 0.01mps # translation speed, below this threshold is skipped
    threshold_rotation: angular_rate = 0.01radps # rotational speed, below this threshold is skipped
    wait_for_first_transform: bool = true # start measuring with the first received message
    tf_topic_namespace: string = ''      # if set, it's used as namespace
    use_sim_time: bool = false           # in simulation, we need to look up the transform at a different time as the scenario execution node is not allowed to use the sim time

action assert_topic_latency:
    # Check the latency of the specified topic (in system time). If the check with comparison_operator gets true, the action ends with failure.
    topic_name: string                   # topic name to wait for message
    latency: time                        # the time to compare against
    comparison_operator: comparison_operator = comparison_operator!le # the comparison is done using the python operator module
    rolling_average_count: int = 1       # the check is done aganist the rolling average over x elements
    wait_for_first_message: bool = true  # start measuring with the first received message
    topic_type: string                   # class of message type, only required when wait_for_first_message is set to false (e.g. std_msgs.msg.String)

action check_data:
    # Compare received topic messages using the given comparison_operator, against the specified value. Either the whole message gets compared or a member defined by member_name.
    topic_name: string                   # name of the topic to connect to
    topic_type: string                   # class of the message type (e.g. std_msgs.msg.String)
    qos_profile: qos_preset_profiles = qos_preset_profiles!system_default # qos profile for the subscriber
    member_name: string = ""             # name of the member to check, if empty the whole message is checked
    expected_value: string               # expected value of the variable
    comparison_operator: comparison_operator = comparison_operator!eq # one from the python `operator module`_
    fail_if_no_data: bool = false        # py_trees.common.Status.FAILURE instead of py_trees.common.Status.RUNNING if there is no data on action execution
    fail_if_bad_comparison: bool = false # py_trees.common.Status.FAILURE instead of py_trees.common.Status.RUNNING if comparison failed
    wait_for_first_message: bool = true  # start checking with the first received message after action execution. If false, the check is executed on the last received message

action differential_drive_robot.odometry_distance_traveled:
    # Wait until a defined distance was traveled, based on odometry
    distance: length                     # traveled distance at which the action succeeds.
    namespace_override: string = ''      # if set, it's used as namespace (instead of the associated actor's name)

action differential_drive_robot.tf_close_to:
    # Wait until a TF frame is close to a defined reference point
    threshold: length                    # distance at which the action succeeds
    reference_point: position_3d         # z is not considered
    robot_frame_id: string = 'base_link' # defines the TF frame id of the robot 
    sim: bool = false                    # in simulation, we need to look up the transform map --> base_link at a different time as the scenario execution node is not allowed to use the sim time
    namespace_override: string = ''      # if set, it's used as namespace (instead of the associated actor's name)

action log_check:
    # Check the ROS log for specific output
    module_name: string = ''             # If specified, a matching message must also match the module name
    values: list of string               # string to check for. If found, action succeeds

action record_bag:
    # Record a dataset, stored in output_dir defined by command-line parameter (default: '.')
    topics: list of topics               # Topics to records, if empty all topics are recorded
    timestamp_suffix: bool = true        # Add a timestamp suffix to output directory name
    hidden_topics: bool = false          # whether to record hidden topics
    storage: string = ''                 # storage type to use (empty string: use default)
    use_sim_time: bool = false           # use simulation time for message timestamps by subscribing to the /clock topic

action ros_launch:
    # Execute a ros launch file
    package_name: string                 # package that contains the launch file
    launch_file: string                  # launch file name
    arguments: list of key_value         # ros arguments (get forwarded as key:=value pairs)
    wait_for_shutdown: bool = true       # if true, the action waits until the execution has finished
    shutdown_timeout: time = 10s         # (only used if wait_for_shutdown is false) time to wait between SIGINT and SIGKILL getting sent, if process is still running on scenario shutdown

action service_call:
    # Call a ROS service and wait for the reply.
    service_name: string                 # name of the service to connect to
    service_type: string                 # class of the message type (e.g. std_srvs.msg.Empty)
    data: string                         # call content
    transient_local: bool = false

action set_node_parameter:
    # Set a parameter of a node.
    node_name: string                    # name of the node
    parameter_name: string               # name of the parameter
    parameter_value: string              # new value of the parameter

action topic_monitor:
    # subscribe to a topic and store the last message within a variable.
    topic_name: string                   # name of the topic to connect to
    topic_type: string                   # class of the message type (e.g. std_msgs.msg.String)
    target_variable: string              # name of the variable (e.g. a 'var' within an actor instance)
    qos_profile: qos_preset_profiles = qos_preset_profiles!system_default # qos profile for the subscriber
    member_name: string = ""             # if not empty, only the value of the member is stored within the variable

action topic_publish:
    # publish a message on a topic
    topic_name: string                   # name of the topic to connect to
    topic_type: string                   # class of the message type (e.g. std_msgs.msg.String)
    value: string                        # value to publish (can either be a string that gets parsed, a struct or a message object stored within a variable, e.g. stored by topic_monitor())
    qos_profile: qos_preset_profiles = qos_preset_profiles!system_default # qos profile for the subscriber

action wait_for_data:
    # Wait for any message on a ROS topic.
    topic_name: string                   # name of the topic to connect to
    topic_type: string                   # class of the message type (e.g. std_msgs.msg.String)
    qos_profile: qos_preset_profiles = qos_preset_profiles!system_default # qos profile for the subscriber

action wait_for_topics:
    # Wait for topics to get available (i.e. publisher gets available).
    topics: list of topics               # list of topics to wait for
