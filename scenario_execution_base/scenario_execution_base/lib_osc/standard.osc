###########
# Standard: OpenSCENARIO 2.0 domain model
# Copyright: ASAM 2021-2022
# Version:
# Standard Publication Date:
# Publication Reference Document:
# Reference Document Date:
###########

# ATTENTION: This file is modified to be compatible with
#            the feature set of scenario execution.

########################
# Scalar types and units
########################

# tag::library-physical-length[]
type length is SI(m: 1)
unit nanometer  of length is SI(m: 1, factor: 0.000000001)
unit nm         of length is SI(m: 1, factor: 0.000000001)
unit micrometer of length is SI(m: 1, factor: 0.000001)
unit millimeter of length is SI(m: 1, factor: 0.001)
unit mm         of length is SI(m: 1, factor: 0.001)
unit centimeter of length is SI(m: 1, factor: 0.01)
unit cm         of length is SI(m: 1, factor: 0.01)
unit meter      of length is SI(m: 1, factor: 1)
unit m          of length is SI(m: 1, factor: 1)
unit kilometer  of length is SI(m: 1, factor: 1000)
unit km         of length is SI(m: 1, factor: 1000)
unit inch       of length is SI(m: 1, factor: 0.0254)
unit feet       of length is SI(m: 1, factor: 0.3048)
unit mile       of length is SI(m: 1, factor: 1609.344)
unit mi         of length is SI(m: 1, factor: 1609.344)
# end::library-physical-length[]

# tag::library-physical-time[]
type time is SI(s: 1)
unit millisecond of time is SI(s: 1, factor: 0.001)
unit ms          of time is SI(s: 1, factor: 0.001)
unit second      of time is SI(s: 1, factor: 1)
unit sec         of time is SI(s: 1, factor: 1)
unit s           of time is SI(s: 1, factor: 1)
unit minute      of time is SI(s: 1, factor: 60)
unit min         of time is SI(s: 1, factor: 60)
unit hour        of time is SI(s: 1, factor: 3600)
unit h           of time is SI(s: 1, factor: 3600)
# end::library-physical-time[]

# tag::library-physical-speed[]
type speed is SI(m: 1, s: -1)
unit meter_per_second    of speed is SI(m: 1, s: -1, factor: 1)
unit mps                 of speed is SI(m: 1, s: -1, factor: 1)
unit kilometer_per_hour  of speed is SI(m: 1, s: -1, factor: 0.277777778)
unit kmph                of speed is SI(m: 1, s: -1, factor: 0.277777778)
unit kph                 of speed is SI(m: 1, s: -1, factor: 0.277777778)
unit mile_per_hour       of speed is SI(m: 1, s: -1, factor: 0.447038889)
unit mph                 of speed is SI(m: 1, s: -1, factor: 0.447038889)
unit miph                of speed is SI(m: 1, s: -1, factor: 0.447038889)
unit mmph                of speed is SI(m: 1, s: -1, factor: 0.000000278)
unit millimeter_per_hour of speed is SI(m: 1, s: -1, factor: 0.000000278)
# end::library-physical-speed[]

# tag::library-physical-acceleration[]
type acceleration is SI(m: 1, s: -2)
unit meter_per_sec_sqr          of acceleration is SI(m: 1, s: -2, factor: 1)
unit mpsps                      of acceleration is SI(m: 1, s: -2, factor: 1)
unit mpss                       of acceleration is SI(m: 1, s: -2, factor: 1)
unit kilometer_per_hour_per_sec of acceleration is SI(m: 1, s: -2, factor: 0.277777778)
unit kmphps                     of acceleration is SI(m: 1, s: -2, factor: 0.277777778)
unit mile_per_hour_per_sec      of acceleration is SI(m: 1, s: -2, factor: 0.447038889)
unit miphps                     of acceleration is SI(m: 1, s: -2, factor: 0.447038889)
# end::library-physical-acceleration[]

# tag::library-physical-jerk[]
type jerk is SI(m: 1, s: -3)
unit meter_per_sec_cubed of jerk is SI(m: 1, s: -3, factor: 1)
unit mpspsps             of jerk is SI(m: 1, s: -3, factor: 1)
unit mile_per_sec_cubed  of jerk is SI(m: 1, s: -3, factor: 1609.344)
unit mipspsps            of jerk is SI(m: 1, s: -3, factor: 1609.344)
# end::library-physical-jerk[]

# tag::library-physical-angle[]
type angle is SI(rad: 1)
unit degree of angle is SI(rad: 1, factor: 57.295779513)
unit deg    of angle is SI(rad: 1, factor: 57.295779513)
unit radian of angle is SI(rad: 1, factor: 1)
unit rad    of angle is SI(rad: 1, factor: 1)
# end::library-physical-angle[]

# tag::library-physical-angular_rate[]
type angular_rate is SI(rad: 1, s: -1)
unit degree_per_sec of angular_rate is SI(rad: 1, s: -1, factor: 57.295779513)
unit degps          of angular_rate is SI(rad: 1, s: -1, factor: 57.295779513)
unit radian_per_sec of angular_rate is SI(rad: 1, s: -1, factor: 1)
unit radps             of angular_rate is SI(rad: 1, s: -1, factor: 1)
# end::library-physical-angular_rate[]

# tag::library-physical-angular_acceleration[]
type angular_acceleration is SI(rad: 1, s: -2)
unit degree_per_sec_sqr of angular_acceleration is SI(rad: 1, s: -2, factor: 57.295779513)
unit degpsps            of angular_acceleration is SI(rad: 1, s: -2, factor: 57.295779513)
unit radian_per_sec_sqr of angular_acceleration is SI(rad: 1, s: -2, factor: 1)
unit radpsps            of angular_acceleration is SI(rad: 1, s: -2, factor: 1)
# end::library-physical-angular_acceleration[]

# tag::library-physical-mass[]
type mass is SI(kg: 1)
unit gram     of mass is SI(kg: 1, factor: 0.001)
unit kilogram of mass is SI(kg: 1, factor: 1)
unit kg       of mass is SI(kg: 1, factor: 1)
unit ton      of mass is SI(kg: 1, factor: 1000)
unit pound    of mass is SI(kg: 1, factor: 0.45359237)
unit lb       of mass is SI(kg: 1, factor: 0.45359237)
# end::library-physical-mass[]

# tag::library-physical-temperature[]
type temperature is SI(K: 1)
unit K          of temperature is SI(K: 1, factor: 1)
unit kelvin     of temperature is SI(K: 1, factor: 1)
unit celsius    of temperature is SI(K: 1, factor: 1, offset: 273.15)
unit C          of temperature is SI(K: 1, factor: 1, offset: 273.15)
unit fahrenheit of temperature is SI(K: 1, factor: 0.555555556, offset: 255.372222222)
unit F          of temperature is SI(K: 1, factor: 0.555555556, offset: 255.372222222)
# end::library-physical-temperature[]

# tag::library-physical-pressure[]
type pressure is SI(kg: 1, m: -1, s: -2)
unit newton_per_meter_sqr of pressure is SI(kg: 1, m: -1, s: -2, factor: 1)
unit Pa                   of pressure is SI(kg: 1, m: -1, s: -2, factor: 1)
unit pascal               of pressure is SI(kg: 1, m: -1, s: -2, factor: 1)
unit hPa                  of pressure is SI(kg: 1, m: -1, s: -2, factor: 100)
unit atm                  of pressure is SI(kg: 1, m: -1, s: -2, factor: 101325)
# end::library-physical-pressure[]

# tag::library-physical-luminous_intensity[]
type luminous_intensity is SI(cd: 1)
unit cd      of luminous_intensity is SI(cd: 1, factor: 1)
unit candela of luminous_intensity is SI(cd: 1, factor: 1)
# end::library-physical-luminous_intensity[]

# tag::library-physical-luminous_flux[]
type luminous_flux is SI(cd: 1, rad: 2)
unit lm    of luminous_flux is SI(cd: 1, rad: 2, factor: 1)
unit lumen of luminous_flux is SI(cd: 1, rad: 2, factor: 1)
# end::library-physical-luminous_flux[]

# tag::library-physical-illuminance[]
type illuminance is SI(cd: 1, rad: 2, m: -2)
unit lx  of illuminance is SI(cd: 1, rad: 2, m: -2, factor: 1)
unit lux of illuminance is SI(cd: 1, rad: 2, m: -2, factor: 1)
# end::library-physical-illuminance[]

# tag::library-physical-electrical_current[]
type electrical_current is SI(A: 1)
unit ampere of electrical_current is SI(A: 1, factor: 1)
unit A      of electrical_current is SI(A: 1, factor: 1)
# end::library-physical-electrical_current[]

# tag::library-physical-amount_of_substance[]
type amount_of_substance is SI(mol: 1)
unit mole of amount_of_substance is SI(mol: 1, factor: 1)
unit mol  of amount_of_substance is SI(mol: 1, factor: 1)
# end::library-physical-amount_of_substance[]

###########
# Structs
###########

# tag::library-position_3d[]
struct position_3d:
    x: length = 0.0m
    y: length = 0.0m
    z: length = 0.0m
    #def norm() -> length is undefined
# end::library-position_3d[]

# tag::library-celestial_position_2d[]
struct celestial_position_2d:
    azimuth: angle = 0.0rad
    elevation: angle = 0.0rad
# end::library-celestial_position_2d[]

# tag::library-geodetic_position_2d[]
struct geodetic_position_2d:
    latitude: angle = 0.0rad
    longitude: angle = 0.0rad
# end::library-geodetic_position_2d[]

# tag::library-orientation_3d[]
struct orientation_3d:
    roll: angle = 0.0rad
    pitch: angle = 0.0rad
    yaw: angle = 0.0rad
# end::library-orientation_3d[]

# tag::library-pose_3d[]
struct pose_3d:
    position: position_3d
    orientation: orientation_3d
# end::library-pose_3d[]

# tag::library-translational_velocity_3d[]
struct translational_velocity_3d:
    x: speed = 0.0mps
    y: speed = 0.0mps
    z: speed = 0.0mps
#    def norm() -> speed is undefined
# end::library-translational_velocity_3d[]

# tag::library-orientation_rate_3d[]
struct orientation_rate_3d:
    roll: angular_rate = 0.0radps
    pitch: angular_rate = 0.0radps
    yaw: angular_rate = 0.0radps
# end::library-orientation_rate_3d[]

# tag::library-velocity_6d[]
struct velocity_6d:
    translational: translational_velocity_3d
    angular: orientation_rate_3d
# end::library-velocity_6d[]

# tag::library-translational_acceleration_3d[]
struct translational_acceleration_3d:
    x: acceleration = 0.0mpsps
    y: acceleration = 0.0mpsps
    z: acceleration = 0.0mpsps
#    def norm() -> acceleration is undefined
# end::library-translational_acceleration_3d[]

# tag::library-orientation_acceleration_3d[]
struct orientation_acceleration_3d:
    roll: angular_acceleration = 0.0radpsps
    pitch: angular_acceleration = 0.0radpsps
    yaw: angular_acceleration = 0.0radpsps
# end::library-orientation_acceleration_3d[]

# tag::library-acceleration_6d[]
struct acceleration_6d:
    translational: translational_acceleration_3d
    angular: orientation_acceleration_3d
# end::library-acceleration_6d[]

struct axle:
    max_steering: angle               # Mandatory: Maximum steering angle for the wheels on the axle.
    wheel_diameter: length            # Mandatory: Diameter for the wheels on this axle
    track_width: length               # Mandatory: Distance between the centerline of the outer wheels on opposing sides of the axle
    position_x: length                # Mandatory: Longitudinal position of the axle in the x-axis of the vehicle. For a 2-axle vehicle, the rear axle must have position_x = 0m
    position_z: length                # Mandatory: Vertical position of the axle in the vehicle's z-axis
    number_of_wheels: uint            # Mandatory: Number of wheels on the axle.

struct bounding_box:
    center: position_3d               # Mandatory: Represents the geometrical center of the bounding box expressed in coordinates that refer to the coordinate system of the physical_object
    length: length                    # Mandatory: Dimension in x-direction of the coordinate system of the physical_object
    width: length                     # Mandatory: Dimension in y-direction of the coordinate system of the physical_object
    height: length                    # Mandatory: Dimension in z-direction of the coordinate system of the physical_object

struct crossing_type:
    marking: crossing_marking         # Optional: Define the type of markings on the crossing
    use: crossing_use                 # Optional: Define the type of use for the crossing
    elevation: crossing_elevation     # Optional: Define the type of elevation for the crossing


#########################
# MODIFICATION: type definition must be done before usage
#########################

enum path_interpolation: [
    straight_line,          # Join the points with straight lines
    smooth]                 # Join the points with a smooth line

struct route:                                   # Object of map
    length: length                              # Optional: Nominal length of the route, measured along the s-axis of the route. Does not apply to route_point
    directionality: directionality              # Mandatory: Directionality for movement of traffic_participant actors on the route
    min_lanes: uint                             # Optional: Minimum number of drivable lanes along this route. Applies only to these children: road, lane_section
    max_lanes: uint                             # Optional: Maximum number of drivable lanes along this route. Applies only to these children: road, lane_section
    anchors: list of string                     # Optional: The strings in here can be matched to unique items in the map files specified in file_name
#    def start_point() -> route_point is undefined
#    def end_point() -> route_point is undefined

struct route_point inherits route_element:
    route: route                      # Mandatory: route in which this point is located
    #s: length = 0.0m                    # Optional: Coordinate along the s-axis of the corresponding route #TODO: s gets misinterpreted
    t: length = 0.0m                    # Optional: Coordinate along the t-axis of the corresponding route

struct xyz_point inherits route_element:
    position: position_3d                # Optional: Position in Cartesian (xyz) coordinates

struct odr_point inherits route_element:
    road_id: string                      # Mandatory: ASAM OpenDRIVE identifier for the road
    lane_id: string                      # Optional: ASAM OpenDRIVE identifier for the lane. If specified, the t-coordinate is measured from the lane centerline. If not specified, the t-coordinate is measured from the ASAM OpenDRIVE reference line
#    s: length = 0.0m                    # Optional: Coordinate along the ASAM OpenDRIVE s-axis
    t: length = 0.0m                     # Optional: Coordinate along the ASAM OpenDRIVE t-axis

# tag::library-path[]
struct path inherits route:
    points: list of pose_3d           # Mandatory: List of points in world x-y-z-coordinates. The individual pose_3d elements can have unconstrained coordinates.
    interpolation: path_interpolation # Mandatory: Choose how to join the points of the path.

struct relative_path:
    interpolation: path_interpolation # Mandatory: Choose how to join the points of the path.

struct relative_path_pose_3d inherits relative_path:
    points: list of pose_3d          # Mandatory: List of points in world x-y-z-coordinates. The individual pose_3d elements can have unconstrained coordinates.

struct relative_path_st inherits relative_path:
    points: list of route_point       # Mandatory: Sequence of route_point that form the relative path

struct relative_path_odr inherits relative_path:
    points: list of odr_point         # Mandatory: Sequence of odr_point that form the relative path
# end::library-path[]

# tag::library-trajectory[]
struct trajectory:
    points: list of pose_3d           # Mandatory: List of points in world x-y-z-coordinates. The individual pose_3d elements can have unconstrained coordinates.
    time_stamps: list of time         # Mandatory: Time stamps for each element in points. The lists time_stamps and points must have the same length
    interpolation: path_interpolation # Mandatory: Choose how to join the points of the trajectory.

struct relative_trajectory:
    time_stamps: list of time         # Mandatory: Time stamps for each element in points. The lists time_stamps and points must have the same length
    interpolation: path_interpolation # Mandatory: Choose how to join the points of the trajectory.

struct relative_trajectory_pose_3d inherits relative_trajectory:
    points: list of pose_3d           # Mandatory: List of points in world x-y-z-coordinates. The individual pose_3d elements can have unconstrained coordinates.

struct relative_trajectory_st inherits relative_trajectory:
    points: list of route_point       # Mandatory: Sequence of route_point that form the relative trajectory

struct relative_trajectory_odr inherits relative_trajectory:
    points: list of odr_point         # Mandatory: Sequence of odr_point that form the relative trajectory
# end::library-trajectory[]

# tag::library-shape-any[]
struct any_shape
#    def duration() -> time is undefined

struct any_acceleration_shape inherits any_shape
#    def compute(time: time) -> acceleration is undefined

struct any_speed_shape inherits any_shape
#    def compute(time: time) -> speed is undefined

struct any_position_shape inherits any_shape
#    def compute(time: time) -> length is undefined

struct any_lateral_shape inherits any_shape
#    def compute(time: time) -> length is undefined
# end::library-shape-any[]

# tag::library-shape-common[]
struct common_acceleration_shape inherits any_acceleration_shape:
    rate_profile: dynamic_profile
    rate_peak: jerk = 0.0mpspsps
    target: acceleration = 0.0mpsps

struct common_speed_shape inherits any_speed_shape:
    rate_profile: dynamic_profile
    rate_peak: acceleration = 0.0mpsps
    target: speed = 0.0mps

struct common_position_shape inherits any_position_shape:
    rate_profile: dynamic_profile
    rate_peak: speed = 0.0mps
    target: length = 0.0m

struct common_lateral_shape inherits any_lateral_shape:
    rate_profile: dynamic_profile
    rate_peak: speed = 0.0mps
    target: length = 0.0m
# end::library-shape-common[]

struct bm_engine                        # Reference to an object representing the bm_engine, whose content is implementation-dependent.
    # Fields to be defined by the user or implementation

struct behavioral_model:
    bm_engine: bm_engine                # Reference to the "behavioral model engine"

###########
# Enums
###########

enum color: [
    white,                    # RGB(255,255,255)
    silver,                   # RGB(192,192,192)
    gray,                     # RGB(128,128,128)
    black,                    # RGB(0,0,0)
    red,                      # RGB(255,0,0)
    maroon,                   # RGB(128,0,0)
    yellow,                   # RGB(255,255,0)
    olive,                    # RGB(128,128,0)
    lime,                     # RGB(0,255,0)
    green,                    # RGB(0,128,0)
    aqua,                     # RGB(0,255,255)
    teal,                     # RGB(0,128,128)
    blue,                     # RGB(0,0,255)
    navy,                     # RGB(0,0,128)
    fuchsia,                  # RGB(255,255,0)
    purple]                   # RGB(255,0,255)

enum intended_infrastructure: [
    driving,                  # OpenDRIVE: "normal" drivable road, which is not one of the other types
    sidewalk,                 # OpenDRIVE: Lane on which pedestrians can walk safely
    biking,                   # OpenDRIVE: Lane reserved for Cyclists
    rail,                     # OpenDRIVE: Lane reserved for trains
    tram,                     # OpenDRIVE: Lane reserved for trams
    bus,                      # OpenDRIVE: Lane reserved for bus
    taxi,                     # OpenDRIVE: Lane reserved for taxi
    hov]                      # OpenDRIVE: Lane reserved for High Occupancy Vehicles (HOV)

enum vehicle_category: [
    car,                     # Power-driven vehicle with maximum mass not exceeding 3.5 t having at least four wheels comprising not more than eight seats in addition to the driver seat.  (UN category L7,M1,N1)
    bus,                     # Power-driven vehicle having at least four wheels comprising more than eight seats in addition to the driver seat.(UN category M2,M3)
    truck,                   # Power-driven vehicle with maximum mass exceeding 3.5t having at least four wheels. Designed for the carriage of goods. (UN category N2,N3)
    trailer,                 # Vehicle designed to be towed by another vehicle. Non-permanently connected to towing vehicle, meaning it can be separated by an operation without involving facilities normally only found in workshop.
    vru_vehicle,             # Vehicle without a crash-resistant passenger cell intended for one to few passengers or small goods transport. With its occupant it results in a vulnerable road user. (UN category L1-L6 plus bicycles, pedelecs, e-bicycles, personal mobility devices, wheelchairs, mobility scooters and so on.)
    other]                   # Unspecified but known type of vehicle (for example, stroller, shopping cart, etc)

enum driving_rule: [
    left_hand_traffic,       # Traffic drives on the left side of the road
    right_hand_traffic]      # Traffic drives on the right side of the road

enum directionality: [
    uni_direction,           # A traffic_participant can move legally in only one direction along the s-axis.
    longitudinal,            # Usually applies to lane_type driving and vru_vehicles
    bi_direction,            # A traffic_participant can move legally in both directions along the longitudinal s-axis. Usually applies to lane_type driving and vru_vehicles
    split,                   # Applies for multi-lane elements: there are lanes with opposing uni_direction traffic flow within the route
    free,                    # A traffic_participant can legally move in any direction (longitudinal or lateral). Usually applies to lane_type pedestrian or lane_use mix_traffic_vru
    none,                    # No expected traffic flow. Usually applies to lane_type non_driving
    other]                   # Other type of directionality

enum lane_type: [
    driving,                 # Driving lane for road vehicles. See the driving_lane_use subtype
    non_driving,             # Non-driving lanes in road vehicles infrastructure. See the non_driving_lane_use subtype
    vru_vehicles,            # Lanes designated for VRU vehicles. See the vru_vehicles_lane_use subtype
    pedestrian,              # Lanes for pedestrians. See the pedestrian_lane_use subtype
    other]                   # If the lane has another type

enum lane_use: [
    normal,                  # A normal driving lane for road vehicles (OSI). Should be used in combination with lane_type == driving.
    exit,                    # A deceleration lane in parallel to the main road (OSI). Should be used in combination with lane_type == driving.
    entry,                   # An acceleration lane in parallel to the main road (OSI). Should be used in combination with lane_type == driving.
    on_ramp,                 # A ramp from rural or urban roads joining a motorway (OSI). Should be used in combination with lane_type == driving.
    off_ramp,                # A ramp leading off a motorway onto rural or urban roads (OSI). Should be used in combination with lane_type == driving.
    connecting_ramp,         # A ramp that connects two motorways (OSI). Should be used in combination with lane_type == driving.
    hov,                     # A lane for High Occupancy Vehicles (HOV), usually in highways. Should be used in combination with lane_type == driving.
    bus,                     # A lane restricted for use only by busses. Should be used in combination with lane_type == driving.
    mixed_traffic_vru,       # A lane for mixed car and vru (vehicle and pedestrian) traffic, normally in urban areas. Should be used in combination with lane_type == driving or vru_vehicles.
    parking,                 # A lane with parking spaces (OSI). Should be used in combination with lane_type == non_driving.
    stop,                    # A hard shoulder on motorways for emergency stops (OSI). Should be used in combination with lane_type == non_driving.
    restricted,              # A lane on which road vehicles should not drive (OSI). Should be used in combination with lane_type == non_driving.
    border,                  # A hard border on the edge of a road (OSI). Should be used in combination with lane_type == non_driving.
    shoulder,                # A soft border on the edge of a road (OSI). Should be used in combination with lane_type == non_driving.
    curb,                    # An elevated surface with different height compared to the drivable lanes. Should be used in combination with lane_type == non_driving.
    median,                  # An inaccessible lane for road vehicles and pedestrians. Typically used to separate the traffic. Should be used in combination with lane_type == non_driving.
    bicycle,                 # A lane that is designated for bicycles (OSI). Should be used in combination with lane_type == vru_vehicles.
    motorcycle,              # A lane that is designated for motorcycles. Should be used in combination with lane_type == vru_vehicles.
    sidewalk,                # A lane that is designated for pedestrians (OSI). Should be used in combination with lane_type == pedestrian.
    protected_sidewalk,      # A lane for pedestrians with a barrier to separate it from road traffic. Should be used in combination with lane_type == pedestrian.
    none,                    # The lane has no use.
    other]                   # The lane has another use.

enum side_left_right: [
    left,
    right]

enum crossing_marking: [     # Has connection to crossing_type
    unmarked,                # No crossing-markings on the road
    marked,                  # The road or walking surface has markings that indicate a crossing
    zebra,                   # Common type of marked crossing with thick zebra stripes
    other]                   # Other type of markings for the crossing

enum crossing_use: [         # Has connection to crossing_type
    pedestrian,              # Crossing is used by pedestrians (person, animal) and/or vehicles that usually move on sidewalks (wheelchair, stroller)
    animal,                  # Animal crossing. For example, on a rural road or highway
    bicycle,                 # Crossing for bicycles
    rail_road,               # Crossing for rail vehicles (train, subway, tram, ...)
    other]                   # Other use for crossing

enum crossing_elevation: [
    road_level,              # Crossing is at same level as driving surface
    curb_level,              # Crossing is elevated from driving surface, often at the same level as a walking surface (sidewalk) or curb
    refuge_island,           # Along the crossing, the elevation may change between road and curb levels. For example, with refuge island(s) in the middle
    other]                   # Another elevation type

enum junction_direction: [
    straight,                # The out_road is 0deg relative to the in_road
    right,                   # The out_road is 90deg relative to the in_road
    u_turn,                  # The out_road is 180deg relative to the in_road
    left,                    # The out_road is 270deg relative to the in_road
    other]                   # If none of the above apply

enum route_overlap_kind: [
    equal,                   # Both routes have the same length, and coincide at the start and end points
    start,                   # Both routes coincide at their start points
    end,                     # Both routes coincide at their end points
    inside,                  # The first route is fully inside the second route. Their start and end points do not have to coincide
    any,                     # Any part of the first route overlaps with any part of the second route
    other]                   # If none of the above apply

enum lateral_overlap_kind: [
    never,                   # The two routes never overlap laterally. They never share a common lane.
    sometimes,               # In some segments of the route, the two routes can share a common lane.
    always ]                 # The always routes share a common lane.

enum dynamic_profile: [
    none,                    # No specific dynamic profile
    constant,                # Use constant first derivative
    smooth,                  # Use smooth first derivative
    asap]                    # Reach value as soon as possible

enum lane_change_side: [
    left,                    # Lane to the left of the reference entity
    right,                   # Lane to the right of the reference entity
    inside,                  # Lane to the inside of the reference entity
    outside,                 # Lane to the outside of the reference entity
    same]                    # Same lane as the reference entity

enum gap_direction: [
    ahead,                   # Gap in the positive direction of the s-axis, with respect to the reference entity
    behind,                  # Gap in the negative direction of the s-axis, with respect to the reference entity
    left,                    # Gap in the positive direction of the t-axis, with respect to the reference entity
    right,                   # Gap in the negative direction of the t-axis, with respect to the reference entity
    inside,                  # Gap in the direction pointing towards opposing traffic
    outside]                 # Gap in the direction pointing away from opposing traffic

enum headway_direction: [
    ahead,                   # Headway in the positive direction of the s-axis, with respect to the reference entity
    behind]                  # Headway in the negative direction of the s-axis, with respect to the reference entity

enum lat_measure_by: [
    left_to_left,
    left_to_center,
    left_to_right,
    center_to_left,
    center_to_right,
    right_to_left,
    right_to_center,
    right_to_right,
    closest]

enum yaw_measure_by: [
    length_to_length,
    length_to_width,
    width_to_length,
    width_to_width,
    relative_to_north,
    relative_to_road]

enum orientation_measured_by: [
    absolute,
    relative_to_reference,
    relative_to_road]

enum movement_options: [
    prefer_physical,        # Perform the movement physical if possible
    prefer_non_physical,    # Perform the non physical way if the implementation allows that. For example, a test track may ignore this request.
    must_be_physical]       # An error message is issued, if this action cannot be physically performed for any reason.

enum connect_route_points: [
    road,                   # Use the road element that contains this point
    lane_section,           # Use the lane_section element that contains this point
    lane,                   # Use the lane element that contains this point
    crossing,               # Use the crossing element that contains this point
    waypoint]               # Use the point itself. The route must pass exactly through this point

enum at: [
    start,
    end,
    all]

enum movement_mode: [
    monotonous,            # This movement mode adheres to the laws of physics. On top of that it limits the level of surprise that a movement may have.
    other]                 # Not necessarily monotonous. This is the default.

enum track: [
    actual,                # Actual or projected. The default is actual, meaning that the vehicle reacts to the behavior of the referenced vehicle.
    projected]             #

enum distance_direction: [
    longitudinal,          # Measure distance in the x-coordinate. Positive means that the `reference` is in front of the `physical_object` that calls the method.
    lateral]               # Measure distance in the y-coordinate. Positive means that the `reference` is to the left of the `physical_object` that calls the method.

enum distance_mode: [
    reference_points,      # Measures the distance between the reference points.
    bounding_boxes]        # Measures the distance between the bounding boxes.

enum relative_transform: [
    world_relative,
    object_relative,
    road_relative,
    lane_relative
]

enum on_route_type: [ on_road, on_lane_section, on_lane, on_crossing ]

enum route_distance_enum: [ from_start, from_end ]

###########
# Actor
###########

actor osc_actor

actor physical_object inherits osc_actor:
    bounding_box: bounding_box                               # Mandatory: See bounding_box struct
    color: color                                             # Optional: See color enum
    geometry_reference: string                               # Optional: Opaque reference of an associated 3D geometry model of the physical object. It is implementation-specific how model references are resolved to 3D models.
    center_of_gravity: position_3d                           # Mandatory: Center of gravity of the object. If unknown, the center of the bounding box may be used instead.
    var pose: pose_3d                                        # Position and orientation measured in world coordinates with world system as reference.
#    def object_distance(reference: physical_object, direction: distance_direction, mode: distance_mode = reference_points) -> length is undefined
#    def get_s_coord(route_type: on_route_type = on_road) -> length is undefined
#    def get_t_coord(route_type: on_route_type= on_road) -> length is undefined
#    def get_route_point(route_type: on_route_type = on_road) -> route_point is undefined

actor stationary_object inherits physical_object

actor movable_object inherits physical_object:
#    def distance_along_route(route: route, from: route_distance_enum = from_start) -> length is undefined
    var velocity: velocity_6d                                 # Mandatory: Translational and rotational velocity measured in object coordinates with world system as reference.
    var acceleration: acceleration_6d                         # Mandatory: Translational and rotational acceleration measured in object coordinates with world system as reference.
    var speed: speed                                          # Mandatory: Speed in center_of_gravity defined as sqrt(velocity.translational.x^2 + velocity.translational.y^2) * sign(velocity.translational.x)

actor traffic_participant inherits movable_object:
    intended_infrastructure: list of intended_infrastructure            # Mandatory: See intended_infrastructure for definition. Intended usage is for further specification of an entity. For example, together with vehicle_category or to provide hints for implemenations where to spawn and / or auto-route entities. Note that multiple types of infrastructure can be assigned because of the list character of this type.
#    def time_to_collision(reference: physical_object) -> time is undefined
#    def time_headway(reference: physical_object) -> time is undefined
#    def space_gap(reference: physical_object, direction: distance_direction) -> length is undefined

actor vehicle inherits traffic_participant:
    vehicle_category: vehicle_category                        # Mandatory: See vehicle_category
    axles: list of axle                                       # Mandatory: See axle
    rear_overhang: length                                     # Mandatory: Rear overhang of the vehicle or more explicitly the horizontal distance between the end of the bounding_box and the center of the rear axle.

actor person inherits traffic_participant

actor animal inherits traffic_participant

###########
# environment (an Actor)
###########
struct weather:
    air: air                             # Optional: See struct air
    rain: precipitation                  # Optional: Liquid water in form of droplets falling under gravity.
    snow: precipitation                  # Optional: Frozen water in delicately-crystalline flakes falling under gravity.
    wind: wind                           # Optional: See struct wind
    fog: fog                             # Optional: See struct fog
    clouds: clouds                       # Optional: See struct clouds

actor environment inherits osc_actor:
    geodetic_position: geodetic_position_2d # Optional: Geodetic position of world coordinate frame regarding WGS84. Regarding usage for determination of angle of celestial light sources see remark above.
    datetime: time                       # Optional: Date and time at start of scenario as Unix time, i.e. Number of seconds that have elapsed since January 1, 1970 (midnight UTC/GMT), not counting leap seconds. Regarding usage for determination of angle of celestial light sources see remark above.
    var weather: weather                 # Optional: See struct weather
    sun: celestial_light_source          # Optional: Sun as instance of celestial_light_source.
    moon: celestial_light_source         # Optional: Moon as instance of celestial_light_source.
#    def local_to_unix_time(year: uint, month: uint, day: uint, hour: uint, minute: uint, second: uint, time_zone: float) -> time is undefined

struct air:
    temperature: temperature = 25.0celsius            # Optional: Temperature on ground level.
    atmospheric_pressure: pressure = 101325pascal   # Optional: Atmospheric pressure on ground level.
    relative_humidity: float = 0.0                  # Optional: Relative humidity on ground level.

struct precipitation:
    intensity: speed = 0.0mps              # Optional: Global intensity of precipitation given as volumetric flux. In case of (partially) solid precipitation, the equivalent melted volume shall be considered. Note that volumetric flux is describing a volume flow across an area, but after reduction the unit results in the same unit as for speeds. As of now it is not possible in

struct wind:
    speed: speed                         # Mandatory: The expected value of wind speed. To estimate the expected value, rolling mean value over a specific short interval (for example, 3s) can be used.
    direction: angle                     # Mandatory: The origin direction of the wind (not target direction) in the ground/x-y-plane with clockwise increasing values to match common definitions. This results in 0 deg for a wind blowing from the North 90 deg for a wind blowing from the East 90 deg, if x-axis and y-axis are mapped to East and North.

struct fog:
    visual_range: length                 # Mandatory: Value of optical range of visible light in the standard setting, which corresponds to a certain density of fog.

struct clouds:
    cloudiness: uint                     # Mandatory: Using okta scale to define which portion of the sky is covered with clouds. Ranging from 0 for completely clear sky to 8 for a completely overcast sky. Values above 8 shall not be used.

struct celestial_light_source:
    var position: celestial_position_2d  # Mandatory: Position of the light source, see definition of physical type celestial_position_2d.

###########
# Map (an Actor)
###########

actor map inherits osc_actor:
    map_file: string
    routes: list of route
    junctions: list of junction
    driving_rule: driving_rule
#    def odr_to_route_point(road_id: string, lane_id: string, s: length, t: length) -> route_point is undefined
#    def xyz_to_route_point(x: length, y: length, z: length) -> route_point is undefined
#    def route_point_to_xyz(route_point: route_point) -> xyz_point is undefined
#    def outer_side() -> side_left_right is undefined
#    def inner_side() -> side_left_right is undefined
#    def create_route(routes: list of route, connect_points_by: connect_route_points, legal_route: bool) -> compound_route is undefined
#    def create_route_point(route: route, s: length, t: length) -> route_point is undefined
#    def create_xyz_point(x: length, y: length, z: length) -> xyz_point is undefined
#    def create_odr_point(road_id: string, lane_id: string, s: length, t: length) -> odr_point is undefined
#    def create_path(points: list of pose_3d, interpolation: path_interpolation) -> path is undefined
#    def create_path_odr_points(points: list of odr_point, interpolation: path_interpolation, on_road_network: bool) -> path is undefined
#    def create_path_route_points(points: list of route_point, interpolation: path_interpolation, on_road_network: bool) -> path is undefined
#    def create_trajectory(points: list of pose_3d, time_stamps: list of time,interpolation: path_interpolation) -> trajectory is undefined
#    def create_trajectory_odr_points(points: list of odr_point, time_stamps: list of time, interpolation: path_interpolation, on_road_network: bool) -> trajectory is undefined
#    def create_trajectory_route_points(points: list of route_point, time_stamps: list of time, interpolation: path_interpolation, on_road_network: bool) -> trajectory is undefined
#    def resolve_relative_path(relative_path: relative_path, reference: physical_object, transform: relative_transform) -> path is undefined
#    def resolve_relative_trajectory(relative_trajectory: relative_trajectory, reference: physical_object, transform: relative_transform) -> trajectory is undefined
#    def get_map_file() -> string is undefined           #from map.map_file

struct route:                                   # Object of map
    length: length                              # Optional: Nominal length of the route, measured along the s-axis of the route. Does not apply to route_point
    directionality: directionality              # Mandatory: Directionality for movement of traffic_participant actors on the route
    min_lanes: uint                             # Optional: Minimum number of drivable lanes along this route. Applies only to these children: road, lane_section
    max_lanes: uint                             # Optional: Maximum number of drivable lanes along this route. Applies only to these children: road, lane_section
    anchors: list of string                     # Optional: The strings in here can be matched to unique items in the map files specified in file_name
#    def start_point() -> route_point is undefined
#    def end_point() -> route_point is undefined

struct route_element inherits route             # Interface Class (of route)

struct road inherits route_element:
    s_positive: list of lane_section            # Mandatory: List of lane_section elements that flow in the positive direction of the road s-axis
    s_negative: list of lane_section            # Optional: List of lane_section elements that flow in the negative direction of the road s-axis

struct lane_section inherits route_element:
    road: road                                  # Mandatory: Where the lane_section resides
    lanes: list of lane                         # Mandatory: List of lanes that compose the lane_section
    s_axis: lane                                # Mandatory: Choose, which lane is used to determine the s-axis of the lane_section. Must be a member of it.lanes

struct lane inherits route_element:
    lane_section: lane_section                  # Mandatory: Where the lane resides
    lane_type: lane_type                        # Mandatory: Type of lane
    lane_use: lane_use                          # Mandatory: A subtype of the lane_type. Use compatible pairs of lane_type and lane_use
    width: length                               # Optional: Nominal width of the lane

struct crossing inherits route_element:
    start_lane: lane                            # Mandatory: Crossing starts on this lane
    end_lane: lane                              # Mandatory: Crossing ends on this lane
    start_s_coord: length                       # Mandatory: On the starts_from lane, the crossing connects at this point in the lane s-axis (and zero in the t-axis)
    end_s_coord: length                         # Mandatory: On the ends_on lane, the crossing connects at this point in the lane s-axis (and zero in the t-axis)
    width: length                               # Mandatory: Nominal width of the crossing, measured perpendicular to the crossing s-axis
    crossing_type: crossing_type                # Mandatory: Type of crossing

struct junction:
    roads: list of road                         # Mandatory: A list of road

struct compound_route inherits route:
    route_elements: list of route_element       # Mandatory: A list of route_element.

struct compound_lane inherits route:
    lanes: list of lane                         # Mandatory: A list of lane

###########
# Action - movable_object
###########

action osc_actor.osc_action

action movable_object.action_for_movable_object inherits osc_actor.osc_action

action movable_object.move inherits movable_object.action_for_movable_object

action movable_object.remain_stationary inherits movable_object.action_for_movable_object

action movable_object.assign_position inherits movable_object.action_for_movable_object:
    position: position_3d                       # Optional: Desired 3-dimensional position assigned by the user
    route_point: route_point                    # Optional: Desired route_point assigned by the user
    odr_point: odr_point                        # Optional: Desired odr_point assigned by the user

action movable_object.assign_orientation inherits movable_object.action_for_movable_object:
    target: orientation_3d                      # Mandatory: Desired 3-dimensional orientation assigned by the user

action movable_object.assign_speed inherits movable_object.action_for_movable_object:
    target: speed                               # Mandatory: Desired (scalar) speed assigned by the user

action movable_object.assign_acceleration inherits movable_object.action_for_movable_object:
    target: acceleration                        # Mandatory: Desired (scalar) acceleration assigned by the user

action movable_object.replay_path inherits movable_object.action_for_movable_object:
    absolute: path                              # Mandatory: Absolute path. Includes a list of points
    relative: relative_path                     # Mandatory: Relative path. Includes a list of points
#    reference: physical_object with:            # Optional: Use with relative paths. Specify the reference entity that defines the origin for the point coordinates. Default: the actor itself
#        keep(default it == actor)
#    transform: relative_transform with:         # Optional: Use with relative paths. Coordinates of the points are relative to the reference entity. Default = object_relative
#        keep(default it == object_relative)
#    start_offset: length with:                  # Optional: Offset at which to begin following the path, measured from the path's start. Default = 0m
#        keep(default it == 0m)
#    end_offset: length with:                    # Optional: Offset at which to end following the path, measured from the path's end. Default = 0m
#        keep(default it == 0m)

action movable_object.replay_trajectory inherits movable_object.action_for_movable_object:
    absolute: trajectory                        # Mandatory: Absolute trajectory. Includes a list of points and a list of corresponding time stamps
    relative: relative_trajectory               # Mandatory: Relative trajectory. Includes a list of points and a list of corresponding time stamps
#    reference: physical_object with:            # Optional: Use with relative trajectories. Specify the reference entity that defines the origin for the point coordinates. Default: the actor itself
#        keep(default it == actor)
#    transform: relative_transform with:         # Optional: Use with relative trajectories. Coordinates of the points are relative to the reference entity. Default = object_relative
#        keep(default it == object_relative)
#    start_offset: length with:                  # Optional: Offset at which to begin following the trajectory, measured from the trajectory's start. Default = 0m
#        keep(default it == 0m)
#    end_offset: length with:                    # Optional: Offset at which to end following the trajectory, measured from the trajectory's end. Default = 0m
#        keep(default it == 0m)

action movable_object.change_position inherits movable_object.action_for_movable_object:
    target: position_3d                         # Mandatory: Target value for the position at the end of the action
    interpolation: path_interpolation           # Mandatory: The interpolation method used to join the start and end points
    on_road_network: bool                       # Mandatory: The action takes place completely on the road network of the scenario

action movable_object.change_speed inherits movable_object.action_for_movable_object:
    target: speed                               # Mandatory: Target value for the speed at the end of the action
#     rate_profile: dynamic_profile with:         # Optional: Assign a shape for the change of the speed variable. This profile affects the acceleration during action execution
#         keep(default it == none)
    rate_peak: acceleration = 0.0mpsps            # Optional: Target value for the peak acceleration that must be achieved during the action

# action movable_object.keep_speed inherits movable_object.action_for_movable_object

action movable_object.change_acceleration inherits movable_object.action_for_movable_object:
    target: acceleration                        # Mandatory: Target value for the scalar acceleration at the end of the action
#    rate_profile: dynamic_profile with:         # Optional: Assign a shape for the change of the speed variable. This profile affects the jerk during action execution
#        keep(default it == none)
    rate_peak: jerk = 0.0mpspsps                  # Optional: Target value for the peak jerk that must be achieved during the action

action movable_object.keep_acceleration inherits movable_object.action_for_movable_object

action movable_object.follow_path inherits movable_object.action_for_movable_object:
    absolute: path                                # Mandatory: Absolute path. Includes a list of points
    relative: relative_path                       # Mandatory: Relative path. Includes a list of points
#    reference: physical_object with:              # Optional: Use with relative paths. Specify the reference entity that defines the origin for the point coordinates. Default: the actor itself
#        keep(default it == actor)
#    transform: relative_transform with:           # Optional: Use with relative paths. Coordinates of the points are relative to the reference entity. Default = object_relative
#        keep(default it == object_relative)
#    start_offset: length with:                    # Optional: Offset at which to begin following the path, measured from the path's start. Default = 0m
#        keep(default it == 0m)
#    end_offset: length with:                      # Optional: Offset at which to end following the path, measured from the path's end. Default = 0m
#        keep(default it == 0m)

action movable_object.follow_trajectory inherits movable_object.action_for_movable_object:
    absolute: trajectory                          # Mandatory: Absolute trajectory. Includes a list of points and a list of corresponding time stamps
    relative: relative_trajectory                 # Mandatory: Relative trajectory. Includes a list of points and a list of corresponding time stamps
#    reference: physical_object with:              # Optional: Use with relative trajectories. Specify the reference entity that defines the origin for the point coordinates. Default: the actor itself
#        keep(default it == actor)
#    transform: relative_transform with:           # Optional: Use with relative trajectories. Coordinates of the points are relative to the reference entity. Default = object_relative
#        keep(default it == object_relative)
#    start_offset: length with:                    # Optional: Offset at which to begin following the trajectory, measured from the trajectory's start. Default = 0m
#        keep(default it == 0m)
#    end_offset: length with:                      # Optional: Offset at which to end following the trajectory, measured from the trajectory's end. Default = 0m
#        keep(default it == 0m)

###########
# Action - vehicle
###########

action vehicle.action_for_vehicle inherits movable_object.action_for_movable_object

action vehicle.drive inherits vehicle.action_for_vehicle

action vehicle.follow_lane inherits vehicle.action_for_vehicle:
#     offset: length with:                                        # Optional: Default=0.0. Offset from center of the lane for the actor to follow, using the t-axis of the lane
#         keep(default it == 0.0m)
#     rate_profile: dynamic_profile with:                         # Optional: Assign a shape for the change of the lateral position variable (t-axis). This profile affects the lateral velocity during action execution
#         keep(default it == none)
    rate_peak: speed = 0.0mps                                     # Optional: Target value for the peak lateral velocity that must be achieved during the action
    target: lane                                                # Optional: The actor must be in this lane at the start, throughout, and the end of the action. If this argument is ignored, the actor follows the current lane when the action is invoked

action vehicle.change_lane inherits vehicle.action_for_vehicle:
#     num_of_lanes: int with:                                     # Optional: The target lane is "num_of_lanes" to the side of the reference entity. Use in conjunction with "side"
#         keep(default it == 1)
    side: lane_change_side                                      # Optional: Select on which side of the reference entity
#     reference: physical_object with:                            # Optional: Default=it.actor. Reference to the entity that is used to determine the target lane. If this argument is omitted, the actor itself is used as reference
#         keep(default it == actor)
#     offset: length with:                                        # Optional: Default=0.0. Target offset from center of the target lane that the actor follows at the end of the action
#         keep(default it == 0.0m)
#     rate_profile: dynamic_profile with:                         # Optional: Assign a shape for the change of the lateral position variable (t-axis). This profile affects the lateral velocity during action execution '/
#         keep(default it == none)
    rate_peak: speed = 0.0mps                                     # Optional: Target value for the peak lateral velocity that must be achieved during the action
    target: lane                                                # Mandatory: The actor starts and finishes the action in the target lane

action vehicle.change_space_gap inherits vehicle.action_for_vehicle:
    target: length                                              # Mandatory: Target distance between the actor and the reference entity. Distance is measured according to the space_gap() method
    direction: gap_direction                                    # Mandatory: Placement of the actor with respect to the reference entity. [ahead, behind] means distance is measured in the s-axis. [left, right, inside, outside] means distance is measured in the t-axis
    reference: physical_object                                  # Mandatory: The actor reaches the driving distance to this reference entity

action vehicle.keep_space_gap inherits vehicle.action_for_vehicle:
    reference: physical_object                                  # Mandatory: The actor keeps the driving distance to this reference entity
    direction: distance_direction                        # Mandatory: Direction in which the space gap is kept with respect to the reference entity. [longitudinal] to keep distance in the s-axis. [lateral] to keep distance in the t-axis

action vehicle.change_time_headway inherits vehicle.action_for_vehicle:
    target: time                                                # Mandatory: Target time headway between the actor and the reference entity. Time headway is measured according to the time_headway() method
    direction: headway_direction                                # Mandatory: Placement of the actor with respect to the reference entity
    reference: physical_object                                  # Mandatory: The actor reaches the time headway to this reference entity

action vehicle.keep_time_headway inherits vehicle.action_for_vehicle:
    reference: physical_object                                  # Mandatory: The actor keeps the driving distance to this reference entity
    direction: headway_direction                                # Mandatory: Direction in which the space gap is kept with respect to the reference entity. [longitudinal] to keep distance in the s-axis. [lateral] to keep distance in the t-axis

###########
# Action - person
###########

action person.action_for_person inherits movable_object.action_for_movable_object

action person.walk inherits person.action_for_person

###########
# Action - environment
###########

action environment.action_for_environment inherits osc_actor.osc_action

action environment.air inherits environment.action_for_environment:
    temperature: temperature = 25.0celsius
    pressure: pressure = 101325pascal
    relative_humidity: float = 0.0

action environment.rain inherits environment.action_for_environment:
    intensity: speed = 0.0mps

action environment.snow inherits environment.action_for_environment:
    intensity: speed = 0.0mps

action environment.wind inherits environment.action_for_environment:
    speed: speed = 0.0mps
    direction: angle = 0.0rad

action environment.fog inherits environment.action_for_environment:
    visual_range: length = 0.0m

action environment.cloud inherits environment.action_for_environment:
    cloudiness: uint = 0

action environment.assign_celestial_position inherits environment.action_for_environment:
    light_source: celestial_light_source
    azimuth: angle
    elevation: angle

#####################################
# Modifier - location based modifiers
#####################################

# modifier position of movable_object.action_for_movable_object:
#     distance: length                                        # Mandatory: A value with a distance unit.
#     time: time with:                                        # Mandatory: A value with a time unit.
#         keep(default it == 0sec)
#     ahead_of, behind: physical_object                       # Optional: A named instance of the vehicle actor example: example, vehicle2

#     at: at with:                                             # Optional: uses enum at to support: start | end | all (default: all)
#         keep(default it == all)
#     movement_mode: movement_mode with:                       # Optional: uses enum movement_mode: monotonous | other (default: other)
#         keep(default it == other)
#     track: track with:                                       # Optional: uses enum track: actual | projected (default: actual)
#         keep(default it == actual)
#     shape: any_shape                                         # Optional: uses struct any_shape

# modifier distance of movable_object.action_for_movable_object:
#     distance: length                                        # Mandatory: The distance the actor should travel in the current movement.

#     at: at with:                                             # Optional: uses enum at to support: start | end | all (default: all)
#         keep(default it == all)
#     movement_mode: movement_mode with:                       # Optional: uses enum movement_mode: monotonous | other (default: other)
#         keep(default it == other)
#     track: track with:                                       # Optional: uses enum track: actual | projected (default: actual)
#         keep(default it == actual)
#     shape: any_shape                                         # Optional: uses struct any_shape

# modifier lane of movable_object.action_for_movable_object:
#     lane: uint with:                                          # Mandatory: An integer indicating a required lane for a drive
#         keep(default it == 1)
#     same_as: physical_object
#     side_of: physical_object
#     side: side_left_right
#     from: side_left_right

#     at: at with:                                             # Optional: uses enum at to support: start | end | all (default: all)
#         keep(default it == all)
#     movement_mode: movement_mode with:                       # Optional: uses enum movement_mode: monotonous | other (default: other)
#         keep(default it == other)
#     track: track with:                                       # Optional: uses enum track: actual | projected (default: actual)
#         keep(default it == actual)
#     shape: any_shape                                         # Optional: uses struct any_shape

# modifier keep_lane of movable_object.action_for_movable_object:
#     at: at with:                                             # Optional: uses enum at to support: start | end | all (default: all)
#         keep(default it == all)
#     movement_mode: movement_mode with:                       # Optional: uses enum movement_mode: monotonous | other (default: other)
#         keep(default it == other)
#     track: track with:                                       # Optional: uses enum track: actual | projected (default: actual)
#         keep(default it == actual)
#     shape: any_shape                                         # Optional: uses struct any_shape

# modifier lateral of movable_object.action_for_movable_object:
#     distance: length with:                                  # Mandatory: The offset from reference line. The default is [-10.0..10.0]centimeter.
#         keep(default it in [-10.0cm..10.0cm])
#     left_of, right_of, same_as, side_of: physical_object    # Optional:
#     side: side_left_right                                   # Optional:
#     measure_by: lat_measure_by with:                        # Optional: This parameter specifies the measurement start and end points.
#         keep(default it == closest)

#     at: at with:                                             # Optional: uses enum at to support: start | end | all (default: all)
#         keep(default it == all)
#     movement_mode: movement_mode with:                       # Optional: uses enum movement_mode: monotonous | other (default: other)
#         keep(default it == other)
#     track: track with:                                       # Optional: uses enum track: actual | projected (default: actual)
#         keep(default it == actual)
#     shape: any_shape                                         # Optional: uses struct any_shape

# modifier yaw of movable_object.action_for_movable_object:
#     angle: angle                                            # Mandatory: A value with an angle unit. This parameter is mandatory
#     relative_to: physical_object                            # Optional: A named instance of the vehicle actor example: example, vehicle2
#     measure_by: yaw_measure_by with:                        # Optional: Defines reference lines of the context and referenced objects, where width is an x-axis and long is a y-axis.
#         keep(default it == relative_to_road)

#     at: at with:                                             # Optional: uses enum at to support: start | end | all (default: all)
#         keep(default it == all)
#     movement_mode: movement_mode with:                       # Optional: uses enum movement_mode: monotonous | other (default: other)
#         keep(default it == other)
#     track: track with:                                       # Optional: uses enum track: actual | projected (default: actual)
#         keep(default it == actual)
#     shape: any_shape                                         # Optional: uses struct any_shape

# modifier orientation of movable_object.action_for_movable_object:
#     yaw: angle                                              # Mandatory: A value with an angle unit. This parameter is mandatory for either yaw, pitch and roll
#     pitch: angle                                            # Mandatory: A value with an angle unit. This parameter is mandatory for either yaw, pitch and roll
#     roll: angle                                             # Mandatory: A value with an angle unit. This parameter is mandatory for either yaw, pitch and roll
#     relative_to: physical_object                            # Optional: A named instance of the vehicle actor example: example, vehicle2
#     measured_by: orientation_measured_by with:              # Optional: defines how to measure the desired orientation. Values include absolute, relative_to_reference, relative_to_road. the default is relative_to_road
#         keep(default it == relative_to_road)

#     at: at with:                                             # Optional: uses enum at to support: start | end | all (default: all)
#         keep(default it == all)
#     movement_mode: movement_mode with:                       # Optional: uses enum movement_mode: monotonous | other (default: other)
#         keep(default it == other)
#     track: track with:                                       # Optional: uses enum track: actual | projected (default: actual)
#         keep(default it == actual)
#     shape: any_shape                                         # Optional: uses struct any_shape

#modifier along of movable_object.action_for_movable_object:
#    route: route                                            # Mandatory: The route to move on.
#    start_offset: length with:                              # Optional: Offset at which to begin following the route, measured from the route's start. Default = 0m
#        keep(default it == 0m)
#    end_offset: length                                      # Optional: Offset at which to end following the route, measured from the route's end. Default = 0m
#        keep(default it == 0m)

#     at: at with:                                             # Optional: uses enum at to support: start | end | all (default: all)
#         keep(default it == all)
#     movement_mode: movement_mode with:                       # Optional: uses enum movement_mode: monotonous | other (default: other)
#         keep(default it == other)
#     track: track with:                                       # Optional: uses enum track: actual | projected (default: actual)
#         keep(default it == actual)
#     shape: any_shape                                         # Optional: uses struct any_shape

# modifier keep_position of movable_object.action_for_movable_object:
#     shape: any_shape                                         # Optional: uses struct any_shape

#     at: at with:                                             # Optional: uses enum at to support: start | end | all (default: all)
#         keep(default it == all)
#     movement_mode: movement_mode with:                       # Optional: uses enum movement_mode: monotonous | other (default: other)
#         keep(default it == other)
#     track: track with:                                       # Optional: uses enum track: actual | projected (default: actual)
#         keep(default it == actual)

#modifier along_trajectory of movable_object.action_for_movable_object:
#    trajectory: trajectory                                   # The trajectory to move along.
#    start_offset: length with:                               # Offset at which to begin following the trajectory, measured from the trajectory's start. Default = 0m
#        keep(default it == 0m)
#    end_offset: length with:                                 # Offset at which to end following the trajectory, measured from the trajectory's end. Default = 0m
#        keep(default it == 0m)

#     at: at with:                                             # Optional: uses enum at to support: start | end | all (default: all)
#         keep(default it == all)
#     movement_mode: movement_mode with:                       # Optional: uses enum movement_mode: monotonous | other (default: other)
#         keep(default it == other)
#     track: track with:                                       # Optional: uses enum track: actual | projected (default: actual)
#         keep(default it == actual)

# modifier stationary_object.location:
#     pose: pose_3d                                      # Mandatory. Location of the stationary object for the whole scenario.

###########################################
# Modifier - rate of change based modifiers
###########################################

# modifier speed of movable_object.action_for_movable_object:
#     speed: speed                                            # Mandatory: The vehicle's desired speed.
#     faster_than, slower_than, same_as: physical_object      # Optional: A named instance of the actor example: example, vehicle2

#     at: at with:                                             # Optional: uses enum at to support: start | end | all (default: all)
#         keep(default it == all)
#     movement_mode: movement_mode with:                       # Optional: uses enum movement_mode: monotonous | other (default: other)
#         keep(default it == other)
#     track: track with:                                       # Optional: uses enum track: actual | projected (default: actual)
#         keep(default it == actual)
#     shape: any_shape                                         # Optional: uses struct any_shape

# modifier acceleration of movable_object.action_for_movable_object:
#     acceleration: acceleration                              # A value appended with an acceleration unit.
#     faster_than, slower_than, same_as: physical_object      # Optional: A named instance of the actor example: example, vehicle2

#     at: at with:                                             # Optional: uses enum at to support: start | end | all (default: all)
#         keep(default it == all)
#     movement_mode: movement_mode with:                       # Optional: uses enum movement_mode: monotonous | other (default: other)
#         keep(default it == other)
#     track: track with:                                       # Optional: uses enum track: actual | projected (default: actual)
#         keep(default it == actual)
#     shape: any_shape                                         # Optional: uses struct any_shape

# modifier keep_speed of movable_object.action_for_movable_object:
#     at: at with:                                             # Optional: uses enum at to support: start | end | all (default: all)
#         keep(default it == all)
#     movement_mode: movement_mode with:                       # Optional: uses enum movement_mode: monotonous | other (default: other)
#         keep(default it == other)
#     track: track with:                                       # Optional: uses enum track: actual | projected (default: actual)
#         keep(default it == actual)
#     shape: any_shape                                         # Optional: uses struct any_shape

# modifier change_speed of movable_object.action_for_movable_object:
#     speed: speed                                            # Mandatory: The vehicle's desired speed.

#     at: at with:                                             # Optional: uses enum at to support: start | end | all (default: all)
#         keep(default it == all)
#     movement_mode: movement_mode with:                       # Optional: uses enum movement_mode: monotonous | other (default: other)
#         keep(default it == other)
#     track: track with:                                       # Optional: uses enum track: actual | projected (default: actual)
#         keep(default it == actual)
#     shape: any_shape                                         # Optional: uses struct any_shape

# modifier physical_movement of movable_object.action_for_movable_object:
#     option: movement_options

#     at: at with:                                             # Optional: uses enum at to support: start | end | all (default: all)
#         keep(default it == all)
#     movement_mode: movement_mode with:                       # Optional: uses enum movement_mode: monotonous | other (default: other)
#         keep(default it == other)
#     track: track with:                                       # Optional: uses enum track: actual | projected (default: actual)
#         keep(default it == actual)
#     shape: any_shape                                         # Optional: uses struct any_shape

# modifier avoid_collisions of movable_object.action_for_movable_object:
#     avoid: bool                                              # Mandatory: Either true or false.

#     at: at with:                                             # Optional: uses enum at to support: start | end | all (default: all)
#         keep(default it == all)
#     movement_mode: movement_mode with:                       # Optional: uses enum movement_mode: monotonous | other (default: other)
#         keep(default it == other)
#     track: track with:                                       # Optional: uses enum track: actual | projected (default: actual)
#         keep(default it == actual)
#     shape: any_shape                                         # Optional: uses struct any_shape

# modifier change_lane of movable_object.action_for_movable_object:
#     lane: uint with:
#         keep(default it == 1)                                # Mandatory: The number of lanes to change from. The default is 1.
#     side: side_left_right                                    # Optional: Left or right. The side is randomized if not specified.

#     at: at with:                                             # Optional: uses enum at to support: start | end | all (default: all)
#         keep(default it == all)
#     movement_mode: movement_mode with:                       # Optional: uses enum movement_mode: monotonous | other (default: other)
#         keep(default it == other)
#     track: track with:                                       # Optional: uses enum track: actual | projected (default: actual)
#         keep(default it == actual)
#     shape: any_shape                                         # Optional: uses struct any_shape

# ################################
# # Modifier - map based modifiers
# ################################

# modifier map.number_of_lanes:
#     route: route                                            # Mandatory: The route that has these constraints
#     num_of_lanes: uint                                      # Mandatory: The desired number of lanes
#     lane_type: lane_type with:                              # Optional: Apply the constraint to the number of lanes with this type.
#         keep(default it == driving)
#     lane_use: lane_use with:                                # Optional: Apply the constraint to the number of lanes with this use.
#         keep(default it == normal)
#     directionality: directionality with:                    # Optional: Apply the constraint to the number of lanes with this directionality.
#         keep(default it == uni_direction)

# modifier map.routes_are_in_sequence:
#     preceding: route                                        # The first route
#     succeeding: route                                       # The second route, which follows after the first route.
#     road: road                                              # Optional: The road that will contain this sequence of routes.

# modifier map.roads_follow_in_junction:
#     junction: junction                                      # The junction to be used.
#     in_road: road                                           # The chosen road that leads into the junction.
#     out_road: road                                          # The chosen road that leads away from the junction.
#     direction: junction_direction                           # Indicates the direction of the out_road relative to the in_road.
#     clockwise_count: uint                                  # out_road is clockwise_count roads from in_road, counting clockwise.
#     number_of_roads: uint                                   # Total number of in_roads connected to the junction.
#     in_lane: lane                                           # The chosen lane within in_road.
#     out_lane: lane                                          # The chosen lane within out_road.
#     junction_route: route                                   # The element(s) that connect the in_lane or in_road to the out_lane or out_road within the junction.
#     resulting_route: route                                  # The route going from in_lane or in_road to the out_lane or out_road.

# modifier map.routes_overlap:
#     route1: route                                           # Mandatory: The first of the overlapping routes.
#     route2: route                                           # Mandatory: The second of the overlapping routes.
#     overlap_kind: route_overlap_kind                        # Mandatory: The type of expected overlap. Notice route1 is considered the first route to interpret the values of the enum.

# modifier map.lane_side:
#     lane1: lane                                             # Mandatory: The first lane.
#     side: side_left_right                                   # Mandatory: Locate lane1 on this side of lane2.
#     lane2: lane                                             # Mandatory: The second lane.
#     count: uint                                             # Mandatory: How far is lane1 from lane2?
#     lane_section: lane_section                              # Optional: lane_section where the lanes reside.

# modifier map.compound_lane_side:
#     lane1: compound_lane                                    # Mandatory: The first compound_lane
#     side: side_left_right                                   # Mandatory: Locate lane1 on this side of lane2
#     lane2: compound_lane                                    # Mandatory: The second compound_lane
#     count: uint                                             # Mandatory: number of from lane1 from lane2
#     route: route                                            # Optional: The route where the compound lanes reside

# modifier map.end_lane:
#     lane: lane                                              # Mandatory: This lane ends in its current lane_section

# modifier map.start_lane:
#     lane: lane                                              # Mandatory: This lane starts in its current lane_section

# modifier map.crossing_connects:
#     crossing: crossing                                      # Mandatory: The crossing that is connected to the specified lanes
#     start_lane: lane                                        # Mandatory: The lane where crossing starts (starting from the centerline of the lane)
#     end_lane: lane                                          # Mandatory: The destination lane where the crossing ends (ending on the centerline of the lane).
#     start_s_coord: length                                   # Mandatory: The crossing origin derived from a s-position along the centerline of start_lane.
#     start_angle: angle with:                                # Optional: The angle at which the straight centerline of the crossing originates from the start lane. Default is perpendicular.
#         keep(default it == 90deg)

# modifier map.routes_are_opposite:
#     route1: route                                           # Mandatory: The first uni-directional route.
#     route2: route                                           # Mandatory: The second uni-directional route.
#     containing_road: road                                   # Mandatory: The road to which both routes belong.
#     lateral_overlap: lateral_overlap_kind                   # Mandatory: Specifies if the routes overlap lateral, meaning they become a single two-way lane.

# modifier map.set_map_file:
#     file: string                                            # Mandatory: The path and file name for the map file.
